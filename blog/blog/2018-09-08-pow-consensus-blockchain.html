<p><em>Disclaimer:This article is not an introduction to blockchain, it does try to cover some basics of blockchain, but it’s focus is more on the proof-of-work as an approach to solving consensus problem.</em></p>

<h2 id="terminologies-and-breakdown">Terminologies and breakdown</h2>

<p>The title of the article is “consensus mechanisms in blockchain”, which sounds like a title with a lot of heavy words. So let’s try to first breakdown this title and understand each term separately.</p>
<ul>
  <li><strong>Consensus</strong> : “Consensus” in simple terms means reaching an agreement amongst a set of parties about a specific thing like an event or a data value. Consensus is collaborative and cooperative in nature by the parties seeking agreement. So one word mapping, <em>consensus = global agreement</em></li>
  <li>A <strong>Consensus mechanism</strong> is an algorithm or approach through which a multi-party system can reach consensus/<em>agreement</em>.</li>
  <li><strong>Blockchain</strong> : Now coming to the system under discussion today which is blockchain. Blockchain has really been in a huge buzz for a long time and mostly because of its application in the implementation of the bitcoin network which as its creators call it “A peer to peer electronic cash network”. Blockchain as a piece of tech is being studied standalone now in a neutral manner to leverage its strengths that have been used in the bitcoin network. In simple terms blockchain is kind of chain of blocks or a ledger(of blocks) that can keep a record of transactions of any sort, whether it is financial transactions( bitcoin network being the example) or transactions about ownership of assets, documents or even storing the state of computer code(used in “programmable” blockchains like ethereum). This ledger allows us to keep a history of all the transactions that were carried out. In simple terms a blockchain = A ledger/chain of blocks that represent a set of transactions/events and thus record a history of all transactions.</li>
</ul>

<h2 id="distributed-nature-of-blockchain">Distributed nature of blockchain</h2>
<p>Now let’s take a step back, if this ledger were just any ledger that a person/computer system can keep a “local” copy of, then it is not very interesting, the real use of this ledger comes when it becomes “distributed” in nature, i.e, all the parties involved in recording the history of transactions/events participate in maintaining a shared global copy of the ledger that they all should agree to. Again when we say a global copy, there is no one copy uploaded on a centralized server to which each person reads and writes, but rather each party in the network holds one local copy that they try to keep in sync with the rest of the network and if majority of people have the same copy of ledger then we consider that most people are in “consensus” with the history of transactions/events or in other words most people have a common “global view” of the ledger. Maybe for now this seems a simple task, let’s explore the workings of such a distributed ledger system and what sort of problems it can encounter trying to reach the consensus about the state of ledger.</p>

<h2 id="byzantines-generals-and-consensus-problem">Byzantine’s Generals and Consensus problem</h2>

<p>Let’s first setup a very simplified version of a problem called “Byzantine’s Generals Problem”. This is a classic problem modeled in computer networks and distributed systems. The problem is as follows:</p>
<ul>
  <li>There is a group of generals each commanding a portion of Byzantine’s army, encircling a city they are planning to attack. In simplest form the generals must decide upon either to “attack” or “retreat”.</li>
  <li>The generals are separated by sizeable distance and hence can communicate only via some messengers.</li>
  <li>Some of the generals have to send message to other generals about their view on “attack” or “retreat” and then all of them in the end have to agree somehow to either attack or retreat.</li>
  <li>This sets up a series of problem. This situation has an issue of trust and consensus. First problem,whatever information the messenger has given is it untampered or not. Second, also after receiving the information, whatever decision a general has made is it in agreement with all other or at least a majority of generals or not. How to know what is the global view of all the generals about attacking the city. The problem can be made complicated by having traitors in the system.</li>
</ul>

<hr />

<p>The above problem can be modelled in the context of blockchain:</p>
<ul>
  <li>The generals map to the nodes in the blockchain’s network</li>
  <li>The messengers map to the network of communication</li>
  <li>The problem of agreeing to an attack strategy maps to the problem of having a consensus on the global state of transactions of the network.</li>
</ul>

<p>This problem can be solved in blockchain through various consensus mechanism of which we will focus on something called “proof-of-work”.
This consensus mechanism was first outlined in a paper by Satoshi Nakamoto(who is still not known) and in a list of emails in his conversations with his peers.
We will first look at what is involved in proof-of-work and then how it solves the consensus problem.</p>

<h2 id="proof-of-work-fundamentals">Proof-of-work: Fundamentals</h2>
<ul>
  <li>This involves taking a set of transactions broadcasted on a network and forming a “block” out of it that contains in addition to the transaction details, the hash of the previous block of the chain and some other data.</li>
  <li>The nodes that are involved in the network who received this “block”, start “mining” it. Mining is the process where the node computers solve a computationally intensive task to come up with a final solution that will be accepted by the network.</li>
  <li>The task basically is to find something called a “nonce” that on adding to the existing block data described above, generates a hash value with a pattern. In bitcoin’s case the patterns is leading zeros. And to adjust the difficulty, the number of zeroes are increased(more difficult) or decreased(less difficult). To generate a specific hash pattern is a very difficult task and requires a lot of compute power. Furthermore since each block contains hash of parent block, if we change any block in between, it changes the hash of the current block which won’t match the pattern and would lead to rejection and recomputing the blocks above the block which was tempered. Thus changing previous blocks or in other words corrupting the history of transactions is not possible without a majority of nodes agreeing to devote that much compute power.</li>
  <li>Thus if majority nodes are honest and do not try to tamper with the ledger, then faulty nodes do not have enough compute power to destroy the consensus on the previous history of records.</li>
</ul>

<h2 id="proof-of-work-how-it-leads-to-consensus">Proof-of-work: How it leads to consensus</h2>
<ul>
  <li>Each transaction being broadcasted on the network is taken up by nodes and they start computing the hash by finding the nonce.</li>
  <li>Now multiple transactions can be broadcasted at a time. The nodes pick up the first one they receive and start the work.</li>
  <li>The first transaction to be “mined” into a valid block is the one to which most compute power of the network was devoted. Thus more nodes agree on this transaction as being in the ledger. Once the mining is done, nodes broadcast the block and hence their copy of ledger.</li>
  <li>The honest nodes have to drop their work and verify and accept the blockchain copy that is the longest or in other words that which has the highest compute power being devoted. Faulty nodes may try not accept the block and publish a corrupted copy of ledger, but the honest nodes will accept only the longest chain</li>
  <li>If faulty node wants to introduce a corrupted record, it needs to make a longer chain than other and introduce it to network. Since most of the network is honest, they will hold more compute power and the faulty nodes with lesser compute power cannot compete against the network to form a block faster than the rest and make a longer chain.</li>
  <li>Hence the consensus is maintained even in presence of faulty nodes.</li>
</ul>

<h2 id="conclusion-and-ending-remarks">Conclusion and Ending remarks</h2>
<p>Thus proof of work is a consensus mechanism where the nodes vote to back a transaction/record in the ledger by providing their compute power as a vote. The more the votes or “compute power” behind a particular copy of blockchain/ledger, means more parties “agree” on that particular ledger and history of transactions. Thus all the parties can always agree and trust the other nodes by possessing the longest proof-of-work chain and can know for sure that their copy is in sync with the common global view of the ledger.</p>

<p>The proof-of-work chain is how different synchronization, distributed database
and global view problems can be solved.</p>

<p>Blockchains can have other consensus mechanisms as well, like Proof-of-stake, Federated-Byzantine-Fault-Tolerance, Proof-of-activity and so on. But proof-of-work is the earliest of the mechanisms trying to solve the Byzantine Agreement and develop a Byzantine fault tolerant system. It certainly has drawbacks but is one of the most robust mechanisms and many mechanisms still draw the concepts from proof-of-work.</p>

<h2 id="interesting-links-and-furthur-reading">Interesting links and Furthur Reading</h2>
<p>Here is the link to the mails that very exchanged between “satoshi nakamoto” and his peers discussing the idea of “bitcoin and blockchain”:</p>
<ul>
  <li>https://www.mail-archive.com/cryptography@metzdowd.com/msg09959.html</li>
</ul>

<p>Here is the link to the original paper published:</p>
<ul>
  <li>https://bitcoin.org/bitcoin.pdf</li>
</ul>

